<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./assets/css/styles.css" />
    <script src="./assets/js/main.js" defer></script>
    <title>Javascript</title>
  </head>
  <body>
    <header>
      <h1>Javascript Cheat Sheet</h1>
      <nav>
        <!-- ! ----------------------------NAVIGATION ----------------------------------------------------->
        <ul class="nav-list">
          <li class="nav-list-item">
            <a class="nav-link" href="#basic">Basic</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#operators">Operators and Expresion</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#control">Control Flow</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#functions">Functions</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#objects">Objects & Arrays</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#scope">Scope & Clousure</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#event">Event Handling</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#error-handling">Error Handling</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#async">Asynchronous programming</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#dom">DOM Manipulation</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#es6">ES6+ features</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#modules">Modules and Import/export</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#apis">Web APIs and fetch</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#testing">Texting and debugging</a>
          </li>
          <li class="nav-list-item">
            <a class="nav-link" href="#practices">Best Practices</a>
          </li>
        </ul>
      </nav>
    </header>
    <!-- ! -----------------------------------------------MAIN----------------------------------------------------->
    <main>
      <!-- * ---------------------------------Basic Variables and Data Types ------------------------------------------------------>
      <section id="basic">
        <h2 class="heading-section">Basics: Terminal, script, Variables, Types & Strings</h2>
        <!--  -->
        <article class="subarticle">
          <h3>Connect a JavaScript file with &lt;script&gt;&lt;/script&gt;</h3>
            <div class="intro">
              <code>script</code> -> two attributes:
              <code>src="./index.js</code> and <code>defer</code>
              <p>
                (tells the browser to delay the loading of the script until all
                HTML elements are loaded. Alternative: script tag at the end of
                the body element, so defer attribute is not necessary. Less
                modern.)
              </p>
            </div>
        </article>
        <!--  -->
        <article class="subarticle">
          <h3>Console</h3>
            <div class="intro">
              <code>console.log("Hello World!")</code>-> logs into console
            </div>
            
            <div class="small-subarticle">
                <h4 class="sub">Use</h4>
                <code> let number = 33;</code> <br />
                <code>console.log("number is", number)</code>
                ->with a expresion-help before ("number is") to
                orientation in the console<br />
                <code>console.log("the number is" + number)</code> ->
                concatenation <br />
                <code>console.log({number})</code>-> destruckturing to
                see the object in the console <br />
                <code>console.log(`the number is ${number}`)</code> ->
                string literal
            </div>
              
            <div div class="small-subarticle">
                <h4 class="sub">Other:</h4>
                <code>console.clear()</code> -> clears console <br>
                <code>console.error("Error!")</code> -> logs as error into
                    console
            </div>  
              
        </article>    
          <!--  -->
        <article class="subarticle">
            <h3>Variables</h3>
            <div class="small-subarticle">
              <h4>const</h4>
              <code>const</code> -> declares a constant, the value can't
              be changed. Default way to declare variables
            </div>
            <div class="small-subarticle">
              <h4>let</h4>
              <code>let</code> -> declares a variable, the value can be
              changed. Only used when reassigning a new value is
              necessary.
            </div>
            <div class="small-subarticle">
              <h4>var</h4>
              <code>var</code> -> outdated, not used anymore.
            </div>
            <div class="small-subarticle">
              <h4>Assignation</h4>
              IMPORTANT Assignation with <code>=</code> <br />
              <code>let counter = 0;</code>
            </div>
            <div class="small-subarticle">
            <h4>Variable Naming</h4>
              <code>let myFirstVariable = "hello"</code> -> use camel case. Be very specific, longer names are better than shorter:
              <code>updatedFollowerCounter</code> instead of
              <code>counter</code>
            </div>
        </article>
          <!--  -->
        <article class="subarticle">
            <h3>Data Types</h3>
            <div class="small-subarticle">
              <h4 class="sub">Primitive Data Types(7)</h4>
              <ul>
                <li>
                  <code>string</code> -> a sequence of characters: "abcd"
                  (with " ")
                </li>

                <li><code>number</code> -> a number: 1234 (without " ")</li>

                <li>
                  <code>boolean</code> -> a binary statement, can be
                  <code>true</code> or <code>false</code> (without " ")
                </li>
                <li>
                  <code>null</code> -> represents "nothing", is a value used
                  in JavaScript to indicate that a variable has been
                  deliberately set to "no value". It is an explicit value that
                  you can assign to a variable to show that it is empty or has
                  no value.
                </li>
                <li>
                  <code>undefined</code> -> represents the state of "not
                  existing". means that a variable has been declared, but no
                  value has been assigned to it yet. If you access an
                  uninitialised variable, it is set to undefined by default.
                </li>
                <li>
                  <code>BigInt</code> -> uncommon, used for integers larger
                  than 9007199254740991
                </li>
                <li>
                  <code>Symbol</code> -> uncommon, used for creating unique
                  elements
                </li>
              </ul>
              <div class="xsm-container">
                <h4 class="sub">Other (not PDT!!) </h4>
                <p> <code>NaN</code> -> occurs when you perform mathematical
                  operations on values that do not represent valid numbers.
                  For example, if you try to divide a number by a string or
                  perform an invalid mathematical calculation, you will get
                  NaN as the result.</p>
              </div>
            </div>
          </div>
          <div class="small-subarticle">
            <h4 class="sub">String methods & propierties</h4>
            <ul>
              <li><code>length</code> -> let firstName = "John";
                firstName.length // 4
              <p>length is a propierty</p>
              </li>
              <li><code>indexOf</code> -> const text = "Hello World";<br />
                let letterHIndex = text.indexOf("H");
                console.log(letterHIndex) // 0 ;<br />
                let letterAIndex = text.indexOf("a");
                console.log(letterAIndex) //-1 ; <br />
                //in the order starting from 0, spaces are inclusive</li>
              <li><code>search</code> -> const message = "Hello John!";<br />
                let positionJ = message.search("John");
                console.log(positionJ) // 6 <br />
                let positionM = message.search("Martha");
                console.log(positionM) // -1 <br />
                //in the order starting from 0, spaces are inclusive
              </li>
              <li><code>concat()</code> concatenates strings.
                string.concat("moreText") //Variable are posible too
              </li>
              <li><code>charAt()</code> returns the character at a specific position in a string, starting at 0.
               string.charAt(0) // The first character of the string</li>
              <li><code>includes(subString)</code> returns true if the string contains the subString.
                string.includes("hello")// true or false</li>
              <li><code>replace(oldString, newString)</code> replaces a portion of a string and returns the result.
                string.replace("john", "jane")// string include the first time the word jane, not john</li>
              <li><code>replaceAll(oldString, newString)</code> replaces all occurrences, not just the first one.
                string.replace("john", "jane")// string replace all "john" for "jane"</li>
              <li><code>slice()</code> cuts the string up to the specified index and returns the remaining characters.
                string.slice(1)// the string without the first Word <br>
                string.slice(1,2)// the string from the character in index 1 to character in index 2</li> 
              <li><code>substring()</code> also cuts the string based on specified indices (the same as slice, but dont work with negativ values).
              </li>
              <li><code>toLowerCase()</code> converts the string to lowercase.
              </li>
              <li><code>toUpperCase()</code> converts the string to uppercase.
              </li>
              <li><code>toString()</code> converts numbers into strings.
              </li>
              <li><code>trim()</code> returns a string with all whitespace removed from the beginning and end.
              </li>
              <li><code>startsWith(subString)</code> returns true if the string starts with subString..
              </li>
              <li><code>endsWith(subString)</code> returns true if the string ends with subString.
              </li>
              <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#instance_properties">More Methods:MDN</a>
              </li>
              <li>
                <code> -1 </code> is normally used for the representation of
                non-existence or non-detection
              </li>
            </ul>
          
          </div>
        
      </section>
      <!-- * ---------------------------------Operators and Expresion ------------------------------------------------------>
      <section id="operators">
        <h2 class="heading-section">Operators, Expresion and Number</h2>
        <article class="subarticle">
          <h3>Arithmetic operators</h3>
          <p class="intro">let a = 1; let b = 2 ; let c = 3; let result = 0</p>
          <div class="small-subarticle">
            <code>+</code> -><code
            >console.log ("a + b =", (a += b)) ;
          </code>
          // or use = a+b
          </div>
          <div class="small-subarticle">
            <code>-</code> -><code
            >console.log("a - b =", (a -= b));
          </code>
          // or use = a-b
          </div>
          <div class="small-subarticle">
            <code>*</code> -><code
            >console.log("a * b =", (a *= b));</code
          >
          // or use = a*b
          </div>
          <div class="small-subarticle">
            <code>/</code> -><code
            >console.log("a / b =", (a /= b));</code
          >
          // or use = a/b
          </div>
          <div class="small-subarticle">
            <code>%</code> -><code
            >console.log("a % b =", (a %= b));</code
          >// or use = a%b
          </div>
          <div class="small-subarticle">
            <code>**</code> ->
            <code>console.log("a ** b =", (a **= b));</code> //or use
            a**b;
          </div>
          <div class="small-subarticle">
            Incrementation (1) <code>a++</code>
          </div>
          <div class="small-subarticle">
            Decrementation (1) <code>a- -</code>
          </div>
        </article>
        <article class="subarticle">
          <h3>Comparision operators</h3>
            <div class="small-subarticle">
              <code>A === B</code><br />->strict equal: is true if both
              values are equal (including their type).
            </div>
            <div class="small-subarticle">
              <code>A !== B</code><br />->strict not equal: is true if
              both values are not equal (including their type).
            </div>
            <div class="small-subarticle">
              <code>A > B</code><br />->strictly greater than: is true if
              A is greater than B.
            </div>
            <div class="small-subarticle">
              <code>A < B</code><br />->strictly less than: is true if A
              is less than B.
            </div>
            <div class="small-subarticle">
              <code>A >= B</code><br />->greater than or equal: is true if
              A is greater than or equal B.
            </div>
            <div class="small-subarticle">
              <code>A <= B</code><br />-> less than or equal: is true if A
              is less than or equal B.
            </div>
            <div class="small-subarticle">
              IMPORTANT: === and !== are strict equality operators. This
              is what you need almost always. Strict equality checks if
              type and value are the same: "3" === 3 is false.
            </div>
        </article>
        <article class="subarticle">
          <h3>Logical Operators</h3>
          <p class="intro">
              You can combine logical operators with brackets to define
              which operator should be evaluated first.
          </p>
            <div class="small-subarticle">                    
              <code>!A</code><br />->not: flips a true value to false and
              vice versa.
            </div>
            <div class="small-subarticle">                    
              <code>A || B</code><br />->or: is true if either A or B is
              true.
            </div>
            <div class="small-subarticle">                    
              <code>A && B</code><br />->and: is true if both A and B is
              true.
            </div>
        </article>
        <article class="subarticle">
            <h3>Truthy and Falsy Values</h3>
            <p>
              Sometimes you want to have a condition depending on another
              type of value. JavaScript can transform any value into a
              boolean with type coercion. That means that some values act as
              if they were true and others as if they were false: Truthy
              values become true, falsy values become false.
            </p>
            <div class="small-subarticle">
              <p><code>truthy </code>values:</p>
              <ul>
                <li>non zero numbers: 1, 2, -3, etc.</li>
                <li>non empty strings: "hello"</li>
                <li>true</li>
              </ul>
              <p><code>falsy </code>values:</p>
              <ul>
                <li>0 / -0</li>
                <li>null</li>
                <li>false</li>
                <li>undefined</li>
                <li>empty string: ""</li>
              </ul>
            </div>
        </article>
        <article class="subarticle">
          <h3>Numbers Methods</h3>
          <p>let string = "2" // String</p>
          <p>let numberA = 0.12345 //Number</p>
          <p>let numberB = 0.56789 //Number</p>
          
          
          
          <ul>
            <li><code>Number(string)</code>transform to number </li>
            <li><code>.toFixed</code>round up and down . OUTPUT IS A STRING!!
            <p>console.log(numberA.toFixed(3)); //0.123</p>
            <p>console.log(numberB.toFixed()); //1 </p> 
            <p>console.log(numberB.toFixed(3)); //0.568</p>
            </li>  
            <li><code>Math.round()</code>round up and down . OUTPUT IS A NUMBER!!
            <p>console.log(Math.round(numberA)); //0</p>
            <p>console.log(Math.round(numberB)); //1</p>
            </li>
            <li><code>Math.ceil()</code>round ALLWAYS up. OUTPUT IS A NUMBER!!
              <p>console.log(Math.ceil(numberA)); //1</p>
              <p>console.log(Math.ceil(numberB)); //1</p>
              <p></p>
            </li>
            <li><code>Math.floor()</code>round ALLWAYS down. OUTPUT IS A NUMBER!!
              <p>console.log(Math.floor(numberA)); //0</p>
              <p>console.log(Math.floor(numberB)); //0</p>
            </li>
            <li><code>Math.random()</code>always gives us a random number between 0 and 1. You can combinate the methods:
              <div class="small-subarticle">
                <p><code>console.log(Math.random() * 10);</code>Gives us a number between 0 and 10 ( 10 not included)</p>
                <p><code>console.log(Math.ceil(Math.random() * 10));</code>Gives us a random number between 1 and 10 (10 Included)</p>
                <p><code>console.log(Math.round(Math.random() * 10))</code>radom number from 0 - 10</p>
                <p><code>console.log(Math.round(Math.random() * 10 + 1));</code>radom number from 1 - 10</p>
              </div>
            </li>
            <li><code>console.log(Math)</code> you see all the Methods</li>

          </ul>

        
        </article>
        
      </section>
      <!-- * ---------------------------------control ------------------------------------------------------>
      <section id="control">
        <h2 class="heading-section">Control flow</h2>
        <article class="subarticle">
          <h3>Conditional statements</h3>
            <div class="small-subarticle">
              <h4> if / (else if) else</h4>
              <p>        
                With an if statement we can control whether a part of our code
                is executed or not, based on a condition.
              </p>
              <p> The <code>else</code> block is executed only if the condition is
                false.
              </p>
              <br>
              <code>
                if (hour < 12) { <br />
                console.log("Good Morning."); <br />
                } else if (hour < 18) { <br />
                console.log("Good afternoon.");<br />
                } else if (hour === 24) { <br />
                console.log("Good night."); <br />
                } else { <br />
                console.log("Good evening."); <br />
                }
              </code>
              <div class="small-subarticle">
                <p>
                  If the condition is not a boolean, it is converted into one by
                  type coercion. This can be used to check whether a value is
                  not 0 or an empty string:
                </p>
                <br>
                <code>
                  const name = "Alex";<br />
                  if (name) {<br />
                  console.log("Hi " + name + "!");
                  <br />
                  } // only executed if name is not an empty string
                </code>
              </div>
            </div>
            <div class="small-subarticle">
              <h4>Ternary Operator  ? : </h4>
              <p>
              With if / else statements whole blocks of code can be
              controlled. The ternary operator can be used if you want to
              decide between two expressions, e.g. which value should be
              stored in a variable:
              </p>
              <br>
              <code>condition ? expressionIfTrue : expressionIfFalse;</code>
              <br>
              <br>
              <p>->If the condition is true, the first expression is evaluated,
              otherwise the second expression.</p>
              <br>
              <p>We ALWAYS need an alternative value to true, no matter which: undefined, null, ""</p>
              <code>const greetingText = time < 12 ? "Good morning." : "Good afternoon.";
              </code>
              <div>
                <code>And other example:</code><br>
                <code>let number = 4;</code><br>
                <code>function isEven(number) {</code><br>
                <code>if (number % 2 === 0) {</code><br>
                <code>return true;</code><br>
                <code>} else {</code><br>
                <code>return false;</code><br>
                <code>}</code><br>
                <code>}</code><br>
                <br>
                <code> let resultA = isEven(number)</code><br>
                <code>? `The number ${number} is even`</code><br>
                <code>: `The number ${number} is odd`;</code><br>
              </div>
            </div>
            <div class="small-subarticle">
              <h4>switch</h4>
              <p>
                The "break" statement is necessary in a switch-case statement to exit the switch block after executing the code for a matched case, preventing the execution of subsequent case statements and ensuring that only one case is executed.</p>
              <div>
                <p>We can not put conditions inside switch(), becouse dont work, we need to use a boolean. Only inside the case works the condition</p>
                <p>let number = 100;</p>
                <code>
                  switch (true) {<br>
                    case number > 50:<br>
                    console.log("Number is bigger to 50");<br>
                    break;<br>
                    case number < 50:<br>
                    console.log("Number is small as 50");<br>
                    break;<br>
                    default:<br>
                    console.log("Number is 50");<br>
                    break;<br>
                    }<br>
                </code>
                <p>With strings:</p>
                let acount = "Admin"
                <code>
                  switch (account) { <br>
                  case "Admin":<br>
                  case "Moderator":<br>
                  console.log("You have all the privileges.");<br>
                  break;<br>
                  case "User":<br>
                  console.log("As a user, you can read and comment on posts. Limited rights.");<br>
                  break;<br>
                  default:<br>
                  console.log("Please log in.");<br>
                  }<br>
                </code>
              </div>
            </div>
        </article>
        <article class="subarticle">
          <h3>Loops</h3>
          <p>A loop executes a respective block of code over and over again until an end criteria is met. In JavaScript, two basic types of loops exist:</p>
          <p><code>while</code> while loop: are used when a task needs to be executed until a specific criteria is met.</p>
          <code>
            <p>let string = "a";</p>
            <p>while (string.length <= 8) {</p>
            <p>console.log(string);</p>
            <p>string = string + string;</p>
            <p>}</p>
          </code><br> 
          <p><code>for</code> loop: are commonly used when a given task needs to be executed x times or for each element in an object / array</p>
          <div class="small-subarticle">
            <h4>types of <code>for</code> loops</h4>
            <div class="xsm-container">
              <h4><code>for</code></h4>
              <div>
                <p>for loops are intended for repeating a task a certain number of times. They consist of three internal parts:</p>
                <p>- an internal counter which is increased / decreased every iteration.</p>
                <p>- a criteria which checks the value of the counter. As long as the criteria is true, the loop is executed.</p>
                <p>- a rule how the counter is increased / decreased (in most cases it is increased by 1)</p>
                <code>
                  <p>for (let counter = 0; counter < 4; counter++) {</p>
                  <p>console.log(counter);</p>
                  <p>}</p>
                </code>
                <p>Output(each number on a new line) // 0; 1; 2; 3;</p>
              </div>
            </div>
            <div class="xsm-container">
              <h4><code>for...in</code></h4>
              <div>
                <p>The for...in is a shorthand notation to loop through all keys of an object:</p>
                <code>
                  <p>const user = {</p>
                  <p>name: "Joe",</p>
                  <p>age: 28,</p>
                  <p>email: "joe@mail.com",</p>
                  <p>};</p><br>
                  <p>for (const key in user) {</p>
                  <p>console.log(user[key]);</p>
                  <p>}</p>
                </code>
                <br>
                <p>Output(each string on a new line) // 'Joe'; 28; 'joe@mail.com'</p>
              </div>
            </div>
            <div class="xsm-container">
              <h4><code>for...of</code></h4>
              <div>
                <p>Similar to for...in the for...of loop is a shorthand notation, but for looping through all items of an array.</p>
                <code>
                  <p>const fruits = ["apple", "banana", "melon"];</p>
                  <p>for (const fruit of fruits) {</p>
                  <p>console.log(fruit);</p>
                  <p>}</p>
                </code>
                <br>
                <p>Output (each string on a new line)// 'apple'; 'banana'; 'melon'</p>
              </div>
            </div>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------functions ------------------------------------------------------>
      <section id="functions">
        <h2 class="heading-section">Functions</h2>
        <div class="intro-big"> They contain a set of statements - in other words: They contain
          JavaScript code. Functions have to be defined. When a function is
          defined it can be called an arbitrary number of times.</div>
        <article class="subarticle">
          <h3>Declarationa and expression</h3>
          <div class="small-subarticle">
            <h4>Function Declarations</h4>
            <div class="xsm-container">
              <p>
                Declaration which consists of:<br />
                -the function keyword <br />
                -the function name <br />
                -the function body (JavaScript statements / JavaScript code)
              </p>
              <code
                >function greet() {<br />
                console.log("Hi Friends!");<br />
                console.log("Nice to be here.");<br />
                }</code
              >
            </div>
          </div>
          <div class="small-subarticle">
            <h4>Function Parameters</h4>
            <div class="xsm-container">
              <p>
                Functions can accept parameters. Parameters can be used like
                predefined variables inside the function body. When declaring
                a function we are free to choose a name for the parameters,
                but descriptive, short names should be chosen.
              </p>
              <code
                >function printLetter(name) { <br />
                console.log("Hi " + name + ", hope you are fine. Love,
                Johnny");<br />
                }</code
              ><br /><br />
              <code>
                function printSum(first, second, third) {<br />
                const sum = first + second + third;<br />
                console.log("The sum of your numbers is: " + sum);<br />
                }</code
              >
            </div>
          </div>
          <div class="small-subarticle">
            <h4>Function Calls</h4>
            <div class="xsm-container">
              <p>
                When functions are defined you can call them by writing their
                name, followed by parentheses ("round brackets").
              </p>
              <code>greet();</code><br /><br />
              <code>
                printLetter("Max");<br />
                printLetter("Jordan");</code
              ><br /><br />
              <code
                >printSum(1, 2, 3);<br />
                printSum(3, 4, 5);</code
              ><br />
            </div>
          </div>
          <div class="small-subarticle">
            <h4>Return Statements</h4>
            <p>
              A function can return a value back to the place where it was
              called. This is done via a return statement. A function can
              return only one expression value, but can have multiple return
              statements, in combination with if else statements for
            </p>
            <code
              >function add3Numbers(first, second, third) <br />{ const sum
              = first + second + third; <br />
              return sum;<br />
              } <br />
              const firstSum = add3Numbers(1, 2, 3); // the return value is
              stored in "firstSum", namely 6</code
            >
            <br /><br />
            <code
              >function checkInputLength(inputString) { <br />if
              (inputString.length > 3) { <br />
              return true; <br />
              } else { <br />
              return false;<br />
              } <br />}</code
            >
            <div class="xsm-container">
              <h4 class="sub">Early Return Statements</h4>
              <p>
                As soon as a return statement is reached in a function call,
                the function execution is ended.This behavior can be used to
                our advantage as early return statements (A return statement
                can be left empty, the returned value is then undefined).
              </p>
              <code
                >function setBackgroundColor(color) { <br />
                <span class="bold">// first condition</span><br />
                if(typeOf color !== 'String') { <br />return; <br />}<br />
                <span class="bold">// second condition </span><br />
                if(!color.startsWith('#')) {<br />
                return; <br />} <br /><span class="bold"
                  >// only if all 2 conditions are passed the final line of
                  code is executed.</span
                ><br />
                body.style.backgroundColor = color; <br />}</code
              >
            </div>
          </div>
        </article>
        <article class="subarticle">
          <h3>Arrow Function Expression</h3>
          <code>const addNumbers = (first, second) => { <br />
          return first + second;<br />
          };</code
        >
          <div class="small-subarticle">
            <h4>Implicit Return Statements</h4>
            <div class="xsm-container">
              <p>
                The advantage of arrow functions are possible shorter
                notations when certain criteria apply
              </p>
              <ul>
                <li>
                  <p>
                    1.-Omit the round brackets around the parameters: This
                    is possible, if there is only one input
                  </p>
                  <code
                    >const addOne = (number) => { <br />return number + 1;
                    <br />
                    };</code
                  >
                  <p>can be rewrite as:</p>
                  <code>const addOne = number => number + 1;</code>
                </li>
                <li>
                  <p>
                    2.-Implicit return statements: If the function consists
                    only of a return statement, the curly brackets and the
                    return keyword can be omitted
                  </p>

                  <code
                    >const addNumbers = (first, second) => { <br />
                    return first + second; };</code
                  >
                  <p>can be rewrite as:</p>
                  <code
                    >const addNumbers = (first, second) => first +
                    second;</code
                  >
                </li>
              </ul>
            </div>
          </div>
          <div class="small-subarticle">
            <h3>Call Back Functions</h3>
            <p>A callback function is a function that is passed as an argument into another function.</p>
            <p>The outer function can execute this for: when an event is triggered,when the fetched data arrived on your computer, for each element in an array </p>
            <code>
              <p>button.addEventListener("click", () => {</p>
              <p>console.log("Inside the callback function.");</p>
              <p>});</p>
            </code> <br>
            <p>1.- outer function(Higher Order Functions): addEventListener()</p>
            <p>2.- first argument: 'click'</p>
            <p>3.- second argument: callback function:</p>
            <code>
              <p>() => {</p>
              <p>console.log("Inside the callback function.");</p>
              <p>};</p>
            </code>
            <p>This type of function is called anonymous function, since it is declared without giving it a name</p>
            <p>Higher Order Functions: <code>.then</code>,<code>.forEach</code>,<code>.map</code>,<code>.filter</code></p>
            <p>A callback function can accept parameters:</p>
            <code>
              <p>button.addEventListener("click", (event) => {</p>
              <p>console.log("This button was clicked:", event.target);</p>
              <p>});</p>
            </code>
          </article>

      </section>
      <!-- * ---------------------------------objects ------------------------------------------------------>
      <section id="objects">
        <h2 class="heading-section">Objects and arrays</h2>
        <article class="subarticle">
          <h3>Arrays</h3>
          <ul>
            <li>Arrays aren't primitives but are instead Array objects</li>
            <li>Arrays  are resizable and can contain a mix of different data types</li>
            <li>JavaScript arrays are zero-indexed.</li>
            <li>Last element is at the value of the array's <code>array.length</code> property minus 1.</li>
          </ul>
          <div class="small-subarticle">
            <h4>Access and change elements of one Array </h4>
            <code>
              <p>let array =["a", "b", "c"];</p>
              <p> console.log(array[1])// "b";</p>
              <p> array[2]="d";</p>
              <p>console.log(array);// ["a", "b", "d"]</p>
            </code>
          </div> 
          <div class="small-subarticle">
            <h4>Important Array Methods</h4>
            <div class="xsm-container">
              <h4><code>forEach</code></h4>
              <p>The array method forEach executes some logic for each element within an array.</p>
              <code>
                <p>const pets = ["bird", "cat", "dog", "fish"];</p>
                <p>pets.forEach((pet) => {</p>
                <p>const petElement = document.createElement("p");</p>
                <p>petElement.textContent = pet;</p>
                <p>document.body.append(petElement);</p>
                <p>});</p>
              </code>
            </div>
            <div class="xsm-container">
              <h4><code>map</code></h4>
              <p>The array method map is used to apply a transformation to each element of an array.
                The transformed elements are stored in the newly created array returned by map. The elements in the original array are not being altered.The created and the original array have the same length.</p>
                <code>
                  <p>const pets = ["bird", "cat", "dog", "fish"];
                    </p>
                  <p>const uppercasePets = pets.map((pet) => {</p>
                  <p>return pet.toUpperCase();</p>
                  <p>});</p>
                  <p>console.log(uppercasePets); </p>
                  <p>// ['BIRD', 'CAT', 'DOG', 'FISH']</p>
                </code>
              <p>The callback function provided to map must use a return statement to return a transformed element. map returns a new array.</p>
              <p>You should not use map to trigger a side-effect, like document.createElement</p>
            </div>
            <div class="xsm-container">
              <h4><code>filter</code></h4>
              <p>The array method filter is used to create a new array with a subset of the elements of the original array. The callback function returns a boolean value to define, if an element is being included in the resulting array or not. The original array is not being altered</p>
              <code>
                <p>const pets = ["bird", "cat", "dog", "ferret", "fish"];</p>
                <p>const petsWithF = pets.filter((pet) => {</p>
                <p>return pet.startsWith("f");</p>
                <p>});</p>
                <p>console.log(petsWithF);</p>
                <p>// ['fish']</p>
              </code>
              <p>The callback function provided to filter must use a return statement to return a boolean value.</p>
            </div>
            <div class="xsm-container">
              <h4>Chaining array methods</h4>
              <p>Often times you need to combine multiple array methods to achieve a desired result. Array methods like map and filter, that return a new array, can be chained.</p>
              <p> Instead of storing each array in a separated variable, the methods can be called directly after another. This reduces the amount of code and improves readable.</p>
              <code>
                <p>const pets = ["bird", "cat", "dog", "ferret", "fish"];</p>
                <p>const uppercasePetsWithF = pets</p>
                <p>.filter((pet) => {</p>
                <p>return pet.startsWith("f");</p>
                <p> })</p>
                <p>.map((pet) => {</p>
                <p>return pet.toUpperCase();</p>
                <p>});</p>
                <p>console.log(uppercasePetsWithF); </p>
                <p>// ['FERRET', 'FISH']</p>
              </code>
            </div>
            <div class="xsm-container">
              <h4><code>document.querySelectorAll</code></h4>
              <p>The NodeList returned by document.querySelectorAll is an array-like object. You can use the forEach method to iterate over the DOM elements.</p>
              <code>
                <p>const pets = document.querySelectorAll('[data-js="pet"]');</p>
                <p>pets.forEach((pet) => {</p>
                <p>pet.addEventListener("click", () => {</p>
                <p>// [...]</p>
                <p>});</p>
                <p>});</p>
              </code>
              <p>A NodeList is not an array! Other array methods like <code>map</code> or <code>filter</code>can't be used. If you need to use array methods, you can convert the NodeList to an array using Array.from()</p>
            </div>
            <div class="xsm-container">
              <h4><code>includes</code></h4>
              <p>Use array.includes() to check whether the array contains the specified value. If it does, true is returned, otherwise false.</p>
              <code>
                <p>const colors = ["red", "yellow", "green"];</p>
                <p>colors.includes("yellow"); // true</p>
                <p>colors.includes("blue"); // false</p>
              </code>
            </div>
            <div class="xsm-container">
              <h4><code>find</code> and <code>findIndex</code></h4>
              <p>Use find() to receive the first element of the array that satisfies the provided testing function. Otherwise, it returns undefined.</p>
              <code>
                <p>const colors = ["red", "yellow", "green"];</p>
                <p>colors.find((color) => color.startsWith("g")); // 'green'</p>
                <p>colors.find((color) => color.startsWith("b")); // undefined</p>
              </code>
              <p>Use findIndex() to receive the index of the first element of the array that satisfies the provided testing function. If there is no such element, -1 is returned.</p>
              <code>
                <p>const colors = ["red", "yellow", "green"];</p>
                <p>colors.findIndex((color) => color.startsWith("y")); // 1</p>
                <p>colors.findIndex((color) => color.startsWith("b")); // -1</p>
              </code>
            </div>
            <div class="xsm-container">
              <h4><code>sort</code> and <code>reverse</code></h4>
              <div class="mini">
                <p>Use <code>sort()</code> to sort the elements of an array. You need to provide a callback function in order to tell how the array is sorted.</p>
                <p>sort() converts the elements into strings, then compares their sequences of UTF-16 Code units values. This is why array.sort() without a callback is mostly useless.</p>
                <code>
                  <p>const numbers = [4, 42, 23, 1];</p>
                  <p>numbers.sort((a, b) => a - b);</p>
                  <p>// [1, 4, 23, 42]</p>
                  <p>numbers.sort((a, b) => b - a); </p>
                  <p>// [42, 23, 4, 1]</p>
                  <p></p>
                </code>
                <p>sort() two things inside of the callback function with strings:</p>
                <p>1.- lowercase both strings before comparing them (uppercase works as well)</p>
                <p>2.- using if-statements, be explicit about the return values dependent on the result of the comparison (nameA < nameB and nameA > nameB)</p>
                <p>(In UTF-16, the upper- and lowercase version of the same letter do not have the same value)</p>
                <code>
                <p>const strings = ["Ana", "Peter", "Gaia"];</p>
                <p>strings.sort((a, b) => {</p>
                <p>const nameA = a.toLowerCase();</p>
                <p>const nameB = b.toLowerCase();</p>
                <p>if (nameA < nameB) {</p>
                <p>return -1;</p>
                <p>  }</p>
                <p> if (nameA > nameB) {</p>
                <p>return 1;</p>
                <p>  }</p>
                <p>  return 0;</p>
                <p>});</p>
                <p>console.log(strings); </p>
                <p>// ['Ana', 'Gaia', 'Peter']</p>
                </code>
              </div>
              <div class="mini">
              <p>use <code>reduce</code>to reverse an array, simply use array.reverse(). This can be combined with sort() as well:</p>
                <code>
                  <p>const numbers = [4, 42, 23, 1];</p>
                  <p>const reversedNumbers = numbers.reverse();</p>
                  <p> // [1, 23, 42, 4]</p>
                </code>
            </div>
            </div>
            <div class="xsm-container">
              <h4><code>slice</code></h4>
              <p>It's important to note that some array methods, as sort(), do not create a new array, but mutate the original one.</p>
              <p>This behaviour will often cause errors. To prevent it, just make a copy of the original array using slice().</p>
              <code>
                <p>const numbers = [4, 42, 23, 1];</p>
                <p>console.log(numbers); // [4, 42, 23, 1]</p>
                <p>const sortedNumbers = numbers.slice().sort((a, b) => a - b);</p>
                <p>console.log(sortedNumbers); // [1, 4, 23, 42]</p>
                <p>console.log(numbers); // [4, 42, 23,</p>
                <p></p>
              </code>
            </div>
            <div class="xsm-container">
              <h4><code>some</code> and <code>every</code></h4>
              <div class="mini">
                <p>Use some() to test whether at least one element in the array passes the provided test.</p>
                <code>
                  <p>const colors = ["red", "yellow", "green"];</p>
                  <p>colors.some((color) => color.startsWith("g")); // true</p>
                  <p>colors.some((color) => color.startsWith("i")); // false</p>
                </code>
              </div>
              <div class="mini">
                <p>In order to check if all elements pass the test, use every().</p>
                <code>
                  <p>const colors = ["red", "yellow", "green"];</p>
                  <p>colors.every((color) => color.length > 2); // true</p>
                  <p>colors.every((color) => color.length < 1); // false</p>
                </code>
              </div>
            </div>
            <div class="xsm-container">
              <h4><code>reduce</code></h4>
              <p> is an array method to reduce a list of values into a single value.</p>
              <p>It's main use case is to calculate the sum of an array of numbers.</p>
              <p>starting from the beginning, it executes the callback function on each element of the array, the return value of each calculation is passed to the next calculation (i.e. it becomes the new starting value for the next iteration through the array)the final result is a single value.</p>
              <code>
                <p>const numbers = [4, 42, 23, 1];</p>
                <p>numbers.reduce((a, b) => a + b);</p>
                <p>console.log(numbers); // 70</p>
              </code>
            </div>
          </div>       
          <div class="small-subarticle">
            <h4>How to use the Methods and propierties</h4>
            <p>const array = ["a", "b", "c", "d"]</p>
            <div><code>console.log(array.length);</code><p>// 4 //Output is a number. first element is 1 // length is a property</p></div>
            <div><code>console.log(array.indexOf("d"));</code><p>// 3 //Output is a number. first Index is 0</p></div>
            <div><code>console.log(array.push("e", "f"));</code><p>//["a", "b", "c", "d", "e", "f"]// add behind</p></div>
            <div><code>console.log(array.pop())</code><p>//["a", "b", "c", "d", "e"]// Remove the last one and you can save it in one variable</p></div>
            <div><code>console.log(array.shift())</code><p>//["b", "c", "d", "e"]// Remove before and you can save it in one variable</p></div>
            <div><code>console.log(array.unshift("x", "y"))</code> <p> //["x", "y", "b", "c", "d", "e"]// Add before</p></div>
            <div><code>const text = "Hello JS friends"</code></div>
            <div><code>console.log(text.split())</code><p>//["Hello JS friends"]//Convert to Array</p></div>
            <div><code>console.log(text.split(""))</code><p>//['H', 'e', 'l', 'l', 'o', ' ', 'J', 'S', ' ', 'f', 'r', 'i', 'e', 'n', 'd', 's']//Every single element, space too</p></div>
            <div><code>console.log(text.split(" "))</code><p>//Â ['Hello', 'JS', 'friends']//Separate where space are</p></div>
            <div><code>console.log(text.split(" ").join(" "))</code><p>//"Hello JS friends"//Add the elements with (join) with one space (" ") between</p></div>
            <div><code>console.log(text.split(" ")</code><p></p></div>
            <div><code>const newArray = ["m", "n", "o", "p", "q"]</code></div>
            <div><code>console.log(newArray.slice(1, 3))</code><p>//['n', 'o']//</p>first index is included, last one NO</div>
            <div><code>const otherArray = ["i", "j", "k", "l"]</code></div>
            <div><code>console.log(otherArray.splice(1, 2, "newItem"));</code><p>//['j', 'k'] // array.splice(startIndex, deleteCount(how many), item1, ...) we obtain the rest of the array. After that our Array is changed</p></div>
            <div><code>console.log(otherArray)</code><p>//['i', 'newItem', 'l']</p></div>
            <div><code>const numbersArray= [1, 5, 6, 3, 12]</code></div>
            <div><code>console.log(numbersArray.reverse())</code><p>//[12, 3, 6, 5, 1]</p></div>
            <div><code>console.log(numbersArray.sort())</code><p>//[1, 12, 3, 5, 6]//ASCII sort//Change original Array, recomended to use .slice() before .sort to do a copy</p></div>
            <div><code>console.log(numbersArray.sort((a, b) => a - b))</code><p>// [1, 3, 5, 6, 12] //Change original Array, recomended to use .slice() before .sort to do a copy</p>Ascendet</div>
            <div><code>console.log(numbersArray.sort((a, b) => b - a))</code><p>//[12, 6, 5, 3, 1]  //Change original Array, recomended to use .slice() before .sort to do a copy</p>Descendent</div>
            <div>const fruits = ["apple", "banana", "kiwi"];</div>
            <div><code>fruits.forEach((fruit) => console.log(fruit))</code><p>//apple; banana; kiwi;// All items in new lines</p></div>
            <div><code>const oddNumbers = [3, 5, 7]</code></div>
            <div><code>let evenNumbers = oddNumbers.map((element)=> element+1); console.log(evenNumbers) </code><p>//[4, 6, 8]//</p>Return a Value and a new Array</div>
            <div>Other Important: .include(); .filter(); .every(); .find(); .reduce();</div>
          </div>
        </article>
        <article class="subarticle">
          <h3>Objects</h3>
          <p>Objects are a central powerful function/data type in JS.Objects are a structured data type, which couple their values not to an index, but to a unique key.You can declare an object using {} curly brackets (object literals):</p>
          <div class="small-subarticle">
            <h4>Create objects</h4>
            <p>We can have all types of values types.</p>
            <p>keys can be written as in this example or as strings ("name":"Jane"), being strings we can only access them with the bracket notation (see below).</p>
            <code>
              <p>const person = {</p>
              <p>name: "Jane",</p>
              <p>age: 42,</p>
              <p>admin: true,</p>
              <p>hobbies:["code", "cinema", "walking"]</p>
              <p>socialMedia:{ </p>
              <p>linkedin: "..."</p>
              <p>gitHub: "..."</p>
              <p>},</p>
              <p>city: "Barcelona",</p>
              <p>greet: function() {</p>
              <p>console.log(`Hola, I am ${this.name}`)</p>
              <p>add: (a,b)=> a+b,</p>
              <p>};</p>
            </code>
            <p></p>
          </div>
          <div class="small-subarticle">
            <h4>Accessing, Change Values, Delete and Functions use</h4>
            <p>We can use the dot notation & the bracket notation to access to our Object. With the above person object, we habe the same value:</p>
            <code>
              <p>console.log(person.name)</p>
              <p>console.log(person["name"])</p>
            </code>
            <p>Wenn keys are strings ("name", "city", etc). We can only use bracket notation <code>person["name"]</code></p>
            <p>Rewrite Values:</p>
            <code><p>person.age = 43</p></code>
            <p>Add neu Value & Key:</p>
            <code><p>person.job="Developer"</p></code>
            <p>Delete:</p>
            <code>delete person.job;</code>
            <p>Functions:</p>
            <code>person.greet()//Hola, I am Jane`</code>
            <code>console.log(person.add(1,2))// 3</code>
          </div>
          <div class="small-subarticle">
            <h4>Dynamical with <code>this</code></h4>
            <p>We can give the greet function to other object and <code>this</code>will refer to the new object</p>
            <p>To use this we need allway a traditional function declaration, dont work with arrow funtion</p>
            <code>
              <p>person.greet()//Hola, I am Jane</p>
              <p>let person2 = {</p>
              <p> name: "John",</p>
              <p> age : "23",</p>
              <p>};</p>
              <p>person2.greet = person.greet;</p>
              <p>person2.greet();//Hola, I am John</p>  
            </code>
          </div>
          <div class="small-subarticle">
            <h4>Use funtions in  Objects</h4>
            <code>
              <p>const doThings = {</p>
              <p>add: (a, b) => a + b,</p>
              <p>sub: (a, b) => a - b,</p>
              <p>write: (a, b) => `Hello my name is ${a} and i am ${b} old`,</p>
              <p>},</p>
              <p>console.log(doThings.add(2, 4));</p>
              <p>console.log(doThings.sub(10, 1));</p>
              <p>console.log(doThings.write("Jude", person.age))</p>
            </code>
          </div>
          <div class="small-subarticle">
            <h4>Work with keys, values and loops</h4>
            <p>With <code>for...in</code> loop we can extract the keys and the values together</p>
            <code>
              <p>for (let key in person) {</p>
              <p>console.log(person[key]) //Only works with [..] notation, not dot notation</p>
              <p>console.log(key + ": " + person[key]);</p>
            </code>
          </div>
          <div class="small-subarticle">
            <h4>Interleaved arrays in objects and viceversa.</h4>
            <p>Especially arrays of objects are very often used when working with databases. [{},{},{}]</p>
            <p>Objects in objects are also very frequent.{{},{},{}}</p>
            <p>We cann access combining dot and bracket notation</p>
            <p>console.log(person.socialMedia.gitHub)// ist the same as</p>
            <p>console.log(person.socialMedia["gitHub"]</p>
            <p>Or: let sozialValues = Object.values(person.socialMedia)</p>
            <p>sozialValues[1]</p>
          </div>
          <div class="small-subarticle">
            <h4>Loops with Objects</h4>
            <p>If we habe a Arry of Objects we can use <code>map</code> or <code>forEach</code></p>
            <p>const people = [ {name:"Jane", city:"Barcelona"}, {name:"Joe", city:"Berlin"}, {name:"Jude", city:"Lima"} ]</p>
           <code>
            <p>people.forEach((person) => {</p>
              <p>const card = `&lt;div style="background-color:red">&lt;/div>`</p>
              <p>&lt;h2 style="margin:1rem;">${people.name}&lt;/h2&gt;</p>
              <p>&lt;h2 style="margin:1rem;">${people.city}&lt;/h2&gt;</p>
              <p>&lt;/div&gt; `;</p>
              <p>document.body.insertAdjacentHTML("afterbegin", card);</p>
              <p>});</p>
           </code>
          </div>
          <div class="small-subarticle">  
            <h4>Methods in Objects: Transform Object to Array to use Array methods (map, filter, sort, etc)</h4>
            <p>Extract keys too with: <code>Object.keys(person)</code></p>
            <p>You can use <code>Object.keys().forEach()</code>: </p>
            <code>
              <p>Object.keys(person).forEach((key) => {</p>
              <p>console.log(key + ": " + person[key]);
              </p>
              <p>});</p>
            </code>
            <p>Extract values too with <code>Object.values(person)</code></p>
            <p>Extract entries with <code>const entries = Object.entries(person)</code></p>
            <p>We have now an Array of Arrays and we can access to values like:</p>
            <p><code>console.log(entries[3][1])//cinema</code></p> 
            <p>Transform a Array of entries in a Object <code>Object.fromEntries()</code></p>
            <div class="xsm-container">
              <h4>Other Methods</h4>
              <p><code>Object.hasOwnProperty()</code>//check if the key exist, answer is a Boolean</p>
              <p><code>Object.freeze()</code>Prevents the properties of an object from being modified.</p>
              <p><code>Object.isFrozen()</code>answer is a Boolean</p>
              <p><code>Object.seal()</code>Prevents adding or deleting properties of an object, but allows modifying existing properties.</p>
              <p><code>Object.isSeal()</code>answer is a Boolean</p>
              <p><code>Object.assign(objectA, objectB)</code>Copies the properties of one object to another object.</p>
              <!--  -->
              <p><code>Object.getOwnPropertyNames()</code>Returns an array of all properties of an object, including non-enumerable properties.</p>
              <p>IMPORTANT:<code>Object.is(valueA, valueB)</code>compares two values and determines whether they are strictly equal. Answer is a Boolean</p>
              <p>Object.is() is especially useful for avoiding pitfalls that can arise with JavaScript equality comparison, such as comparing NaN to NaN or comparing 0 to -0.</p>
              <p><code>Object.is(5, 5); // true</code></p>
              <p><code>Object.is(5, "5"); // false</code></p>
              <p><code>Object.is(NaN, NaN); // true</code></p>
              <p><code>Object.is(0, -0); // false </code></p>
              <p><code>Object.is(null, null); // true</code></p>
            </div>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------scope ------------------------------------------------------>
      <section id="scope">
        <h2 class="heading-section">Scope and closures</h2>
        <article class="subarticle">
          <h3>Scope</h3>
          <p class="intro">
            The scope defines where variables are visible and where they
            can be referenced: global scope vs function scope
          </p>
          <div class="small-subarticle">
            <h4>Function scope</h4>
            <div class="xsm-container">
                <span class="bold">Function scope </span>
                <p>-> Variables
                  defined inside a function are not accessible from outside.
                  But all variables outside of the function can be accessed
                  from inside the function body</p> 
                <code>function myFunction() { <br />
                const localVariable = true;<br />
                console.log(localVariable);<br />
                } <br />
                myFunction() // true console.log(localVariable); // Error!
                Variable not available outside of function</code
              >
            </div>
          </div>
          <div class="small-subarticle">
            <h4>Global scope</h4>
            <div class="xsm-container">
              <span class="bold">Global scope </span>
              <p>-> A variable is in
                the global scope when it is declared outside of any
                function, in a JavaScript file. Global variables are visible
                and can be accessed from anywhere in that JavaScript file
                after declaration.</p> 
            </div>
          </div>
        </article>
        <article class="subarticle">
          <h3>Closures</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------event ------------------------------------------------------>
      <section id="event">
        <h2 class="heading-section">Event handling</h2>
        <article class="subarticle">
          <h3>Events</h3>
          <p>The event Object and event.target. The event object is created whenever an event is triggered.</p>
          <p>More info about <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event#properties">Event</a></p>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
        <article class="subarticle">
          <h3>Events listener</h3>
          <div class="small-subarticle">
                <h4 class="sub">.addEventListener()</h4>
                <p>The method addEventListener is used to react to events.
                  There different events you can listen to:</p>
                <a href="https://developer.mozilla.org/en-US/docs/Web/Events#event_listing">List
                </a>
                <p>
                  First you specify the kind of event, e.g. click, then you
                  define what code should be executed when the event is
                  triggered. You write that code between the {} brackets, e.g.
                  a console.log.
                </p>
                <code>
                const button =
                document.querySelector('[data-js="button"]');
                button.addEventListener("click", () => {
                console.log("Yeah"); });
                </code>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------error-handling ------------------------------------------------------>
      <section id="error-handling">
        <h2 class="heading-section">Error handling</h2>
        <article class="subarticle">
          <h3>Try, catch, finally</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
        <article class="subarticle">
          <h3>???</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------async ------------------------------------------------------>
      <section id="async">
        <h2 class="heading-section">Asynchronous programing</h2>
        <article class="subarticle">
          <h3>Asynchronous Code</h3>
          <p>Asynchronous code is code that runs in the background. This is useful for tasks that can take a long time to complete, but don't need to block the main thread.
            JavaScript is a single-threaded language, meaning that only one thing can happen at a time. Examples of asynchronous code include: network requests, file system access, animations and timers.</p>
          <div class="small-subarticle">
            <h4>Promises</h4>
            <p>A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation, and its resulting value. Most of the time it is returned by a function that performs an asynchronous operation.</p>
            <p>The Promise object has the following properties and methods:            </p>
            <p><code>state</code> the state of the Promise object, can be "pending", "resolved" or "rejected"</p>
            <p><code>result</code> the result of the asynchronous operation (you'll almost never need to access this directly)</p>
            <p><code>then()</code>a method that takes a callback function that will be called when the asynchronous operation is complete</p>
            <p><code>catch()</code>a method that takes a callback function that will be called when the asynchronous operation fails</p>
            <p><code>finally()</code>a method that takes a callback function that will be called when the asynchronous operation is complete, regardless of whether it was successful or not</p>
            <p><code>functionThatReturnsAPromise().then((value) => {</code></p>
            <p><code>console.log(value);</code></p>
            <p><code> });</code></p> 
            <p>Promises are almost always created for you by other asynchronous APIs, only rarely do you create them yourself. If you create a Promise yourself (new Promise()), you either know exactly what you are doing, or you are probably doing something wrong.</p>
            <p>Some examples of asynchronous browser APIs that return a Promise:</p>
            <p><code>fetch()</code>â makes an HTTP request and returns a Promise that resolves to a Response object</p>
            <p><code>element.animate().finished </code>â animates an element and returns a Promise that resolves when the animation is complete</p>
            <p><code>navigator.getBattery()</code> â gets the current battery level and returns a Promise that resolves with the battery level</p>
          </div>
          <div class="small-subarticle">
            <h4>Asnyc Functions and Async/await</h4>
            <p>Using the await keyword, you can write asynchronous code that looks synchronous. Any function can be prefixed with the async keyword:</p>
            <code>async function myAsyncFunction() {}</code>
            <code>const myAsyncArrowFunction = async () => {}</code>
            <p>Inside an async function, you can use the await keyword to wait for a Promise to be resolved:</p>
            <code>
              <p>async function myAsyncFunction() {/p>
              <p>const value = await functionThatReturnsAPromise();</p>
              <p>console.log(value);</p>
              <p>}</p>
            </code>
            <p>This is can be easier to read than the Promise syntax especially when you have multiple asynchronous operations that depend on each other.</p>
            <code>
              <p>async function myAsyncFunction() {</p>
              <p>const value1 = await functionThatReturnsAPromise1();</p>
              <p>const value2 = await functionThatReturnsAPromise2(value1);
              </p>
              <p>const value3 = await functionThatReturnsAPromise3(value2);</p>
              <p>console.log(value3);</p>
              <p>}
              </p>
            </code>
            <p>Compared to (avoid doing this):</p>
            <code>
              <p>function myFunction() {</p>
              <p>functionThatReturnsAPromise1()</p>
              <p>.then((value1) => {</p>
              <p>return functionThatReturnsAPromise2(value1);</p>
              <p>})
              </p>
              <p>.then((value2) => {</p>
              <p>return functionThatReturnsAPromise3(value2);</p>
              <p>  })</p>
              <p>.then((value3) => {</p>
              <p>console.log(value3);</p>
              <p>  });</p>
              <p>}
              </p>
              <p>async functions always return a Promise. If the function returns a value, the Promise will be resolved with that value. Even if you're not using the return keyword the function will return a Promise that resolves to undefined when it reaches the end of it's scope. If the function throws an error, the Promise will be rejected with that error.</p>
              <p></p>
            </code>
          </div>
          <div class="small-subarticle">
            <h4>Handling Errors</h4>
            <div class="xsm-container">
              <h4><code>try/catch</code></h4>
              <p>When using Promises, you can use the catch() method to handle errors. Using async functions, you can use the try/catch syntax.</p>
              <code>
                <p>async function myAsyncFunction() {</p>
                <p>try {</p>
                <p>const value = await functionThatReturnsAPromise();</p>
                <p>console.log(value);</p>
                <p>} catch (error) {</p>
                <p>console.error(error);</p>
                <p> }</p>
                <p>}</p>
              </code>
              <p>The try block will be executed, and if an error is thrown, the catch block will be executed. The catch block has access to the error that was thrown.
              If any error is thrown in the try block, the catch block will be executed immediately aborting the execution of any further code in the try block:</p>
            </div>
            <div class="xsm-container">
              <h4><code>finally</code></h4>
              <p>You can also use a finally block after any try block to run code after the try block is resolved, regardless of whether it was successful or not:</p>
              <code>
                <p>async function myAsyncFunction() {</p>
                <p>try {
                </p>
                <p>const value = await functionThatReturnsAPromise();</p>
                <p>console.log(value);
                </p>
                <p>} catch (error) {
                </p>
                <p>console.error(error);</p>
                <p> } finally {</p>
                <p>console.log("done");</p>
                <p>}</p>
                <p>}
                </p>
              </code>
              <p>IMPORTANT: The try/catch/(finally) syntax is not limited to async functions, you can use it with any JavaScript code that might throw an error.</p>
            </div>
            <div class="xsm-container">
              <h4>Parallel Promises: <code>Promise.all()</code></h4>
              <p>If you have multiple asynchronous operations that you want to run in parallel, you can use Promise.all(). It takes an array of Promises and returns a Promise that resolves to an array of the results of the Promises in the same order.</p>
              <code>
                <p>async function myAsyncFunction() {</p>
                <p>try {</p>
                <p> const values = await Promise.all([</p>
                <p>functionThatReturnsAPromise1(),</p>
                <p>functionThatReturnsAPromise2(),</p>
                <p>functionThatReturnsAPromise3(),</p>
                <p> ]);</p>
                <p>console.log(values); // [value1, value2, value3]</p>
                <p>} catch (error) {</p>
                <p>console.error(error);</p>
                <p> }</p>
                <p>}
                </p>
              </code>
              <p>This will run all three asynchronous operations in parallel, and wait for all of them to complete before continuing. If any of the asynchronous operations fail, Promise.all() will fail as well.</p>
              <p>There are advanced use cases where you might want to control when to resolve or reject a Promise. <code>Promise.allSettled()</code> (does not care if Promises are rejected or resolved) and <code>Promise.any()</code> (resolves once the first Promise is resolved) are two methods that allow you to do that.</p>
            </div>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------dom ------------------------------------------------------>
      <section id="dom">
        <h2 class="heading-section">DOM manipulation</h2>
        <p>The Document Object Model is a representation of the HTML document. Each HTML Tag is modelled as a node in a tree structure, which shows how HTML elements are nested. A computer program such as your JavaScript file can access and manipulate the HTML website by changing the DOM via the document object.</p>
        <article class="subarticle">
          <h3>Selecting elements</h3>
          <div class="small-subarticle">
            <h4>.querySelector()</h4>
            <p class="intro">Before we can add interactivity, we need to select the
              necessary HTML-Elements. A good practice is to use a data-*
              attribute, like that:</p>
            <code>const mainElement =
              document.querySelector('[data-js="main"]');</code>
            <p>Other css selectors work as well, but the data-* attribute
              selectors should be preferred.</p>
            <div class="xsm-container">
              <div>
                <code
                >const mainElement = document.querySelector("main");</code
              ><br />
              ->tag as identifier
              </div>
              <div>
                >const mainElement =
                document.querySelector(".main");</code
              ><br />
              ->class as identifier
              </div>
              <div>
                <code
                >const mainElement =
                document.querySelector("#main");</code
              ><br />-> id as identifier
              </div>
            </div>
            <div class="xsm-container">
              <p>Other posibilities:</p>
              <code> querySelector('elementA + elementB');</code><br />
              <code> querySelector('elementA ~ elementB');</code><br />
              <code> querySelector('[attribut="value"]');</code><br />
              <code> querySelector(':pseudo');</code><br />
              <code> querySelector('::pseudo-element');</code><br />
              <code> querySelector(':pseudo');</code><br />
            </div>
          </div>
          <div class="small-subarticle">
            <h4>Other methods to select:</h4>
            <p>
              .querySelectorAll() allows you to find and select
              multiple elements in the DOM based on these selectors
            </p>
            <p>
              <code> querySelectorAll('element')</code><br />
              ->Selects all elements of the specified type.
            </p>
            <p>
              <code> querySelectorAll('.classname')</code><br />
              -> Selects all elements with the specified CSS class.
            </p>
            <p>
              <code> querySelectorAll('#id')</code><br />
              -> Selects the element with the specified ID (Note: IDs
              should be unique)
            </p>
            <p>
              <code> querySelectorAll('[attribute="value"]')</code>
              <br />
              -> Selects all elements with the specified attribute and
              value.
            </p>
            <p>
              <code> querySelectorAll(':pseudo-class')</code> <br />
              -> Selects all elements that match the specified
              pseudo-class, like :hover or :nth-child(n).
            </p>
            <p>
              <code>querySelectorAll('element.classname')</code><br />
              ->to select all elements of a specific type with a
              certain class.
            </p>
            <p>
              <code>getElementById</code><br />
              -> Selects an element by its unique ID attribute.
            </p>
            <p>
              <code>getElementsByClassName</code><br />
              -> Selects elements by their class attribute.
            </p>
            <p>
              <code>getElementsByTagName</code><br />
              -> Selects elements by their HTML tag name.
            </p>
            <p>
              <code>getElementsByName</code><br />
              -> Selects elements by their name attribute.
            </p>
          </div>
        </article>
        <article class="subarticle">
          <h3>Modifiying and use content</h3>
          <p class="intro">
            You can access in the console to all the propierties of
            the element:
          </p>
          <p>
            const mainElement = document.querySelector("#main");
          </p>
          <p>console.log(mainElement.innerHTML)</p>
          <p>console.log(mainElement.clientWidth)</p>
          <p>console.log(mainElement.baseURI)</p>
          <div class="small-subarticle">
            <h4>Output in HTML</h4>
            <div class="xsm-container">
              <h4 class="sub">document.write</h4>
              <p>
                <code>document.write("Hallo People!")</code> -> Add text
                at the <span class="underline">END</span> of our HTML
              </p>

              <code
                >document.write("&lt;h2 class="test" style="color:
                red"&gt;Warning&lt;/h2&gt;")</code
              >
            </div>
            <div class="xsm-container">
              <h4 class="sub">POP UPS</h4>
              <div>
                <code>window.prompt()</code>
                ->text with input (and placeholder). e.g:
                <br />
                let windowInput = window.prompt("WhatÂ´s is yout name?",
                "please, write here your name")
              </div>
              <div>
                <code>window.confirm()</code>-> text with 2 buttons
                yes/no
                <br />
                let confirmStatus = window.confirm("Agree to the
                cookies?);<br />
                // console.log(confirmStatus);
              </div>
            </div>
            <div class="xsm-container">
              <h4 class="sub">innerHTML</h4>
              <div>
                <code>
                  const content = document.querySelector("h1") <br />
                  content.innerHTML += "Hello World!" 
                </code>
                <br />
                <p>//-> With += add a the new text to the old. </p><br />
                <p>//-> With = rewrite all the content !!.</p>
                <code>
                const container = document.querySelector(".container")
                <br />
                container.innerHTML += "&lt;h3&gt; This is a new
                  headline &lt;/h3&gt;"; 
                </code>
                <br />
                <p>//-> Add new HTML Elements</p>
              </div>
            </div>
          </div>
          <div class="small-subarticle">
            <h4>Inputs & Forms</h4>
            <div class="xsm-container">
              <h4>Inputs</h4>
              <p class="intro">Every input field in HTML holds a value in form of a string. You can access the value by using <code>.value</code>  on.You can also change the value of the input by assigning a new value to this input property:</p>
              <code>
                const textInput = document.querySelector('[data-js="textInput"]');<br>
                textInput.value = "changed value!";
              </code>
              <br>
              <p>This change is immediately visible on the website.</p>
              <p>For example, you can enforce all uppercase letters in a form by combining this functionality with an input event listener on the input element:</p>
              <code>
                // transform on every change the input value to uppercase letters <br><br>
                textInput.addEventListener("input", () => {
                const oldValue = textInput.value;<br>
                const newValue = oldValue.toUpperCase();<br>
                textInput.value = newValue;<br>
                });<br>
              </code>
            </div>
            <div class="xsm-container">
              <h4>Forms</h4>
              <p class="intro">To prevent the default behavior we can use: </p>
              <ul>
                  <li>in HTML form we need <code>; return false</code></li>
                  <li><code>&lt;form onsubmit="function(); return false"&gt;&lt;/form&gt;</code></li>                
                  <li>Or in JS use <code>.preventDefault()</code></li>
                  <li> <code>
                    const form = document.querySelector('[data-js="form"]');<br><br>
                    form.addEventListener("submit", (event) => { <br>
                    event.preventDefault();
                    console.log(event.target);<br>
                    });<br>
                  </code></li>
              </ul>
              <div class="mini">
                <h4>The event Object and <code>event.target</code></h4>
                <p>The event Object and event.target. The event object is created whenever an event is triggered.</p>
                <p>event.target is a reference to the element to which the event originated from - in this case - the form.</p>
                <p>More info about <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event#properties">Event</a></p>
              </div>
              <div class="mini">
                <h4>Accessing Interactive Fields: event.target.elements and the name Attribute</h4>
                <p>While event.target represents the entire form, event.target.elements is a collection of all form elements (form fields, field sets and buttons.You get access to a specific form field via its <code>name</code> (&lt;input name="firstName"/&gt;) attribute and dot notation:</p>
                <code>
                  form.addEventListener("submit", (event) => {<br>
                    event.preventDefault();<br>
                    const formElements = event.target.elements;<br>
                    console.log(formElements.firstName);<br>
                    console.log(formElements.firstName.value);<br>
                  });<br>
                </code>
              </div>
              <div class="mini">
                <h4>Using Input Values</h4>
                <p>You can access all input values of the form by using FormData(). This constructor uses event.target and can be transformed into a usable object afterwards:</p>
                <code>
                  form.addEventListener("submit", (event) => {<br>
                    event.preventDefault();<br>
                    const formData = new FormData(event.target);<br>
                    const data = Object.fromEntries(formData);<br>
                    console.log(data);<br>
                  });
                </code>
              </div>
              <div class="mini">
                <h4>Exception: Reading Values from Checkboxes</h4>
                <p>You can access the checkbox's state via the <code>.checked </code> property instead.</p>
                <code>
                  console.log(formElements.colorBlue.checked);<br> // output: true or false <br>
                  console.log(formElements.colorBlue.value);<br> // output (always): blue <br>
                </code>
              </div>
              <div class="mini">
                <h4>The input Event</h4>
                <p>The input event is fired every time when the value of a form field has been changed. For example, a &lt;textarea /&gt; will fire this event with every keystroke.</p>
                <code>
                  const messageField = document.querySelector('[data-js="message"]'); <br><br>
                  messageField.addEventListener("input", (event) => {<br>
                  console.log(event.target.value);<br>
                  });<br>
                </code>
                <p> Don't confuse the input event with the change event, which is only fired after a field's content has been committed by the user by pressing enter or moving the focus to the next field.</p>
              </div>
              <div class="mini">
                <h4>Focus Input Fields <code>.focus()</code></h4>
                <p>This can be used to improve the user experience after submitting a form</p>
                <code>messageField.focus();</code>
                <p>Instead of querying the input element using querySelector, it can also be obtained via the event.target.elements collection:</p>
                <code>event.target.elements.message.focus();</code>
              </div>
              <div class="mini">
                <h4>Resetting Forms <code>.reset()</code></h4>
                <code>
                  form.addEventListener("submit", (event) => { <br>
                    event.preventDefault();<br>
                    // [...] handle form data<br>
                    event.target.reset();<br>
                  });
                </code>
                <p>This often comes in handy in combination with <code>.focus()</code>. After the message was send, the input field is cleared and re-focussed, so users can write the next message.</p>
              </div>
            </div>
          </div>
        </article>
        
        <article class="subarticle">
          <h3>Change style</h3>
          <div class="small-subarticle">
            <h4>.style</h4>
            <p>
              Use <code>.style </code>and the css propierty in without -
              in camelCase;
            </p>
            <p>const mainElement = document.querySelector("#main");</p>
            <p>mainElement.style.backgroundColor = "yellow";</p>
            <p>mainElement.style.fontSize = "20px"</p>
          </div>
          <div class="small-subarticle">
            <h4>.classList</h4>
            <p>Add/remove & toggle classes:</p>
            <div class="xsm-container">
                <code>const main = document.querySelector('[data-js="main"]'); </code>
                <br />
                <br />
                <code>const button = document.querySelector('[data-js="button"]');</code>
                <br />
                <br />
                <code>button.addEventListener("click", () => { </code>
                <br />
              
                <code>main.classList.add("page--primary"); });</code>
                <br />
                <p>Toggle:</p> 
                <code>main.classList.toggle("page--primary");</code>
                <br />
                <p>Remove: </p>
                <code>main.classList.remove("page--primary");</code>
            </div>
          </div>
        </article>
        <article class="subarticle">
          <h3>HTML collection & NodeList</h3>
          <div class="small-subarticle">
              <h4>Html collection</h4>
              <p>An HTML collection is an object-like array of HTML element nodes. It is used in JS to access a group of elements in the DOM = (Document Object Model).</p>
              <p>- HTMLCollections are live! As soon as the HTML changes, so does the collection.</p> 
              <p>- index based - The first element is 0</p> 
              <p>- Often used with document.getElementByClassName(), document.getElementByTagName() or elment.children. (there we get a collection back)</p>  
              <p>How to get access to the individual HTML elements, we have a "form" in Html with the name="loginForm", and 2 input with the names "username" & "email":</p>
              <code>
                <p>let myForm = document.forms.loginForm;</p>
                <p>console.log(myForm.username);</p>
                <p>console.log(myForm.username.value);</p>
                <p>console.log(myForm.email.value);</p>
              </code>  
          </div>
          <div class="small-subarticle">
            <h4>Html collection vs NodeList</h4>
            <p>A NodeList is a collection of nodes, therefore Nodes. Unlike HTML Collection, Nodelist can contain all kinds of DOM nodes.</p>
            <p>Nodes can be static or live.</p>
            <p>- index based - the first element is 0</p>
            <p>NodeList supports more methods than HTML Collections. For example, you can use forEach methods to loop through the list.</p>
            <p> NodeList are often received as return values from DOM methods like document.quarySelectorAll() or Node.childeNodes.</p>
            <p>with the <code>querySelectortAll()</code>  we usually get back a NodeList!</p>
            <code><p>const liNodelist = document.querySelectorAll("li");</p></code>
            <p>with the <code>getElementByTagName</code>  we usually get back an HTML Collection.</p>
            <code><p>const liHTMLCollection = document.getElementsByTagName("li");</p></code>
            <p>Extract Child elements (example):</p>
            <code><p>console.log(document.body.children[0])</p></code>
            <code><p>console.log(document.body.children[0].children)</p></code>
            <code><p>console.log(document.body.children[1].children[2])</p></code>
            <p>Add a child element:</p></code>
            <code><p>document.body.children[0].innerHTML += "&lt;p&gt; I am new here &lt;/p&gt;"</p></code>
            <p>Change Style:</p>
            <code><p>document.body.children[0].children[0].style.color = "red";</p></code>
            <div class="xsm-container">
              <h4> Navigation with <code>firstElementChild</code> and <code>lastElementChild</code> </h4>
              <code>console.log(document.body.firstElementChild);//first element of my HTML</code>
              <code>console.log(document.body.lastElementChild);//last element of my HTML</code>
              <code>console.log(document.body.children[0].lastElementChild);// This is how you can move through Html with these keys</code>
            </div>
          </div>
        </article>
        <article class="subarticle">
          <h3>Creating Elements</h3>
          <p>We can create and add elements with:  </p>
          <ul>
            <li class="xsm-container">
              <h4><code>.createElement</code> and <code>.appendChild</code> or <code>.append</code></h4>
                  <code>
                    <p>let div = document.createElement("div");</p>
                    <p>div.textContent = "I am a new Div"</p>
                    <p>div.style.height = "100px";</p>
                    document.body.appendChild(div);
                  </code>
                  <code>
                    <p>const article = document.createElement("article");</p>
                    <p>const button = document.createElement("button");</p>
                    <p>document.body.append(article); // placing the created article at the end of the body</p>
                    <p>article.append(button); // placing the created button into the article</p>
                  </code>
                  <p>We can create and add elements dynamically with <code>forEach</code></p>
                  <code>
                    <p>let socialMedia = ["meta", "tw", "insta"];</p>
                    <p>socialMedia.forEach((elt) => {</p>
                    <p>let listItem = document.createElement("li");</p>
                    <p>listItem.textContent = elt;</p>
                    <p>document.body.firstElementChild.appendChild(listItem);</p>
                    <p>});</p> 
                  </code>
                  <p>We can add attribute with .setAttribute </p>
                  <code>
                    <p>let image = document.createElement("img")</p>
                    <p>image.setAttribute("src", "https://..........")</p>
                    <p>image.setAttribute("alt", "alt text")</p>
                    <p>image.setAttribute("class", "img-class")</p>
                    <p></p>
                  </code>
                  <p>You can also give it the values, propiertiers and methods directly if the element exists. You can assign HTML attributes by using the element properties</p>
                  <p>Common Element Properties and Methods are: <code>classList</code>,<code>textContent</code>,<code>style</code><code>hidden</code><code>focus()</code> <code>hasAttribute()</code>, <code>querySelector()</code></p>
                  <code>
                    <p>let image = document.createElement("img")</p>
                    <p>img.src = "https://..........";</p>
                    <p>img.alt = "alt text";</p>
                    <p>img.className = "img-class"</p>
                    <p>button.textContent = "Click me!";</p>
                  </code>
            </li>
            <li class="xsm-container">
              <h4>adding the element/tag with <code>.innerHTML +=``</code> </h4>
              <code>document.body.innerHTML +=
                '&lt;img class="img-class" src="https:......" alt="test"&gt;';</code>
            </li>
            <li class="xsm-container">
              <h4>adding the element/tag with <code>.insertAdjacentHTML("location", newElement)</code>.</h4>
              <p>the new element will be the first one after body:</p>
              <code> let html=`&lt;p&gt; I am new here &lt;/p&gt;`; document.body.insertAdjacentHTML("afterbegin", html);</code>
             
              <p>Other locations possibilities:</p> 
              <div><code>beforebeginn</code>, <code>afterbeginn</code> ,<code>beforeend</code>, <code>afterend</code></div>
            </li>
          </ul> 
        </article>
      </section>
      <!-- * ---------------------------------es6 ------------------------------------------------------>
      <section id="es6">
        <h2 class="heading-section">ES6+ features</h2>
        <article class="subarticle">
          <h3>Template literals</h3>
          <div class="small-subarticle">
            <code>let firstName = "Jane";</code><br>
            <code>let lastName = "Doe";</code><br>
            <code>let city = "Los Angeles";</code><br>
            <code>let concatenation = firstName + lastName + " is from " + city;</code><br>
            <code>let templateLiteral = `${firstName} ${lastName} is from ${city}`;</code><br>
          </div>
          <div class="small-subarticle">
            <p>Any expression can be placed into these placeholders:</p>
            <code>const greeting = `Hello ${ <br>
            name !== null ? name : "mysterious person"<br>
            }, good to see you!`;<br>
          </code>
          </div>
        </article>
        <article class="subarticle">
          <h3>Destructuring</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
        <article class="subarticle">
          <h3>Spread operator</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------modules ------------------------------------------------------>
      <section id="modules">
        <h2 class="heading-section">Modules and Import/Export</h2>
        <article class="subarticle">
          <h3>Modules</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
        <article class="subarticle">
          <h3>Import/export</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------apis ------------------------------------------------------>
      <section id="apis">
        <h2 class="heading-section">Web Apis and Fetch</h2>
        <article class="subarticle">
          <h3>Web Apis</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
        <article class="subarticle">
          <h3> Fetch</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------testing ------------------------------------------------------>
      <section id="testing">
        <h2 class="heading-section">Testing and debugging</h2>
        <article class="subarticle">
          <h3>Console methods</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- * ---------------------------------practices ------------------------------------------------------>
      <section id="practices">
        <h2 class="heading-section">Best practices</h2>
        <article class="subarticle">
          <h3>Code Style</h3>
          <div class="small-subarticle">
            <h4></h4>
          </div>
        </article>
      </section>
      <!-- -------------------------------------end -->
    </main>
    <script src="./assets/js/main.js"></script>
  </body>
</html>
